Merci pour ces prÃ©cisions ! Je vais maintenant structurer un guide complet avec :

1. **ThÃ©orie et analogies** pour bien comprendre comment fonctionnent :
   - Les pipes (`|`) en sÃ©rie
   - Les redirections (`<`, `>`, `>>`) et leurs combinaisons
   - Les here-docs (`<<`), en confirmant si l'expansion est nÃ©cessaire
   - Les built-ins (`echo`, `cd`, `pwd`, `export`, `unset`, `env`, `exit`)
   - Le cÅ“ur de l'exÃ©cution (`execve`) et comment tout relier

2. **Un guide pas Ã  pas pour chaque fonctionnalitÃ©**, avec :
   - Une explication dÃ©taillÃ©e
   - Un exemple de code minimaliste
   - Des conseils pour Ã©viter les erreurs et respecter la norme POSIX

3. **Une gestion fidÃ¨le aux erreurs de Bash**, en suivant son comportement (exit codes, `errno`, messages d'erreur, etc.)

Je vais vÃ©rifier si l'expansion (`<< "EOF"`) est requise pour les here-docs et je te prÃ©pare tout Ã§a rapidement ! ğŸ˜Š

# Introduction  
Ce guide dÃ©taillÃ© explique comment construire pas Ã  pas un **minishell** (mini-interprÃ©teur de commandes faÃ§on Bash) en C, en se concentrant sur les fonctionnalitÃ©s clÃ©s requises : pipelines en sÃ©rie, redirections dâ€™entrÃ©es/sorties (y compris here-documents) et commandes *built-in*. Nous aborderons chaque fonctionnalitÃ© dâ€™un point de vue **thÃ©orique** (avec des analogies simples pour bien comprendre) puis **pratique** (avec une implÃ©mentation en C minimaliste conforme aux normes POSIX et au projet Minishell). Nous insisterons Ã©galement sur la gestion prÃ©cise des erreurs pour reproduire fidÃ¨lement le comportement de Bash (codes de sortie, messages dâ€™erreur via `errno`) et donnerons des conseils dâ€™optimisation et de conformitÃ© (utilisation de `libft`, Ã©vitement des fuites, etc.). 

Le guide est structurÃ© selon les grandes Ã©tapes suivantesÂ :  

1. **Pipelines en sÃ©rie (`|`)** â€“ ExÃ©cution de plusieurs commandes reliÃ©es en pipeline.  
2. **Redirections (`<`, `>`, `>>`)** â€“ Redirections dâ€™entrÃ©e/sortie, avec combinaisons possibles.  
3. **Here-documents (`<<`)** â€“ Lecture dâ€™input multi-ligne, avec gestion de lâ€™expansion des variables selon le dÃ©limiteur.  
4. **Built-ins** â€“ ImplÃ©mentation des commandes internes : `echo`, `cd`, `pwd`, `export`, `unset`, `env`, `exit`.  
5. **CÅ“ur de lâ€™exÃ©cution (`execve`)** â€“ Coordination de tous les Ã©lÃ©ments ci-dessus via `fork/execve`, en gÃ©rant les erreurs et la conformitÃ© POSIX.  

Chaque section comporte dâ€™abord une **explication** conceptuelle illustrÃ©e, puis une **implÃ©mentation en C** Ã©tape par Ã©tape, avec du code commentÃ©. 

## 1. Pipelines en sÃ©rie (`|`)  

### 1.1 Comprendre les *pipes* en sÃ©rie  
Une *pipeline* relie la sortie standard (**stdout**) dâ€™une commande Ã  lâ€™entrÃ©e standard (**stdin**) de la suivante. On peut voir cela comme un **tuyau** : la premiÃ¨re commande y dÃ©verse ses donnÃ©es (comme de lâ€™eau) et la seconde les boit en entrÃ©e. En Bash, lâ€™opÃ©rateur `|` sert de connecteur entre les processus. Par exemple, dans `cmd1 | cmd2 | cmd3`, la sortie de `cmd1` est envoyÃ©e directement comme entrÃ©e de `cmd2`, et ainsi de suite. On appelle souvent cela un **chaÃ®nage de processus**. GrÃ¢ce aux pipes, chaque commande peut rester simple (faire une seule tÃ¢che) et le shell se charge de transmettre le flux de lâ€™une Ã  lâ€™autre.  

**AnalogieÂ :** imaginez une chaÃ®ne de montage oÃ¹ chaque ouvrier (processus) prend la production du prÃ©cÃ©dent pour la transformer et la passer au suivant. Les *pipes* jouent le rÃ´le du convoyeur entre chaque ouvrier, assurant un flux continu.  

En interne, un pipe est reprÃ©sentÃ© par une paire de descripteurs de fichier (un pour lâ€™extrÃ©mitÃ© en lecture, un pour lâ€™extrÃ©mitÃ© en Ã©criture). Ã‰crire dans le pipe dâ€™un cÃ´tÃ© permet de lire ces donnÃ©es de lâ€™autre cÃ´tÃ©. Tant que les processus restent connectÃ©s au pipe, les donnÃ©es transitent de maniÃ¨re unidirectionnelle (de la sortie de lâ€™un vers lâ€™entrÃ©e de lâ€™autre).  

**Comportement concurrentÂ :** Toutes les commandes dâ€™un pipeline doivent sâ€™exÃ©cuter **concurremment** (en parallÃ¨le). Contrairement Ã  lâ€™exÃ©cution sÃ©quentielle avec `;`, le shell ne doit pas attendre quâ€™une commande du pipeline se termine pour lancer la suivante â€“ elles tournent en mÃªme temps. Si on forÃ§ait une exÃ©cution strictement lâ€™une aprÃ¨s lâ€™autre, on risquerait des blocages *deadlocks* : par exemple, si `cmd1` produit beaucoup de donnÃ©es et remplit le buffer du pipe, elle attendrait que `cmd2` les lise, or `cmd2` ne dÃ©marrerait quâ€™aprÃ¨s la fin de `cmd1` â€“ blocage assurÃ©. Lâ€™exÃ©cution concurrente Ã©vite cela et correspond au comportement de Bash.  

### 1.2 ImplÃ©mentation dâ€™un pipeline en C  
Pour implÃ©menter les pipes en C dans Minishell, on utilisera principalement les appels systÃ¨me **`pipe()`**, **`fork()`**, **`dup2()`** et **`waitpid()`** :  

- **`pipe(int fd[2])`** : crÃ©e un tube anonyme et place ses deux descripteurs dans `fd[0]` (lecture) et `fd[1]` (Ã©criture).  
- **`fork()`** : crÃ©e un nouveau processus. Le code sâ€™exÃ©cute en double, et on distingue le **processus parent** (retour de fork > 0) et le **processus enfant** (retour = 0). Chaque enfant exÃ©cutera une commande du pipeline.  
- **`dup2(oldfd, newfd)`** : redirige un descripteur vers un autre. Ici on lâ€™emploiera pour brancher lâ€™entrÃ©e/sortie standard sur les extrÃ©mitÃ©s du pipe (ex. dupliquer le *write-end* du pipe sur STDOUT dans le premier processus, et le *read-end* sur STDIN du second).  
- **`waitpid(pid, ...)`** : permet au parent dâ€™attendre la fin dâ€™un processus enfant (et de rÃ©cupÃ©rer son code de sortie). On sâ€™en servira pour attendre **tous** les processus de la pipeline *aprÃ¨s* les avoir lancÃ©s, afin de ne redonner la main Ã  lâ€™utilisateur quâ€™une fois le pipeline terminÃ©.  

**Ã‰tapes de crÃ©ation dâ€™un pipeline de N commandesÂ :**  

1. **CrÃ©er les pipes nÃ©cessaires** : Pour N commandes, on a besoin de N-1 pipes (chaque pipe relie commande i Ã  commande i+1). On peut allouer un tableau `int pipes[N-1][2]` et appeler `pipe()` sur chaque Ã©lÃ©ment avant de forker les processus.  

2. **Lancer chaque commande avec `fork()`** :  
   - Pour chaque commande *i* (0-indexÃ©) dans le pipeline :  
     - On crÃ©e un processus enfant (`pid = fork()`).  
     - Dans lâ€™**enfant** :  
       - Rediriger les descripteurs :  
         - Si *i > 0* (pas la premiÃ¨re commande), alors cette commande doit recevoir lâ€™entrÃ©e du pipe prÃ©cÃ©dent. On fait `dup2(pipes[i-1][0], STDIN_FILENO)` pour brancher lâ€™entrÃ©e standard sur le *read-end* du pipe prÃ©cÃ©dent.  
         - Si *i < N-1* (pas la derniÃ¨re commande), alors sa sortie doit aller dans le pipe suivant. On fait `dup2(pipes[i][1], STDOUT_FILENO)` pour envoyer la sortie standard dans le *write-end* du pipe correspondant.  
       - **Fermer tous les descripteurs de pipe** devenus inutiles dans le fils : aprÃ¨s les dup2, on peut fermer *toutes* les extrÃ©mitÃ©s de pipe (`close(pipes[j][0])` et `close(pipes[j][1]` pour tous j). Cela Ã©vite les fuites de FDs dans les enfants.  
       - **ExÃ©cuter la commande** : si câ€™est une commande externe, construire son chemin et appeler `execve()`. (Pour une *built-in* dans un pipeline, on peut choisir de la traiter comme un externe pour quâ€™elle sâ€™exÃ©cute dans le fils, voir section built-in.) Sâ€™il y a une erreur Ã  lâ€™exec, afficher le message dâ€™erreur appropriÃ© et appeler `_exit(code)` pour terminer le processus enfant.  
     - Dans le **parent** :  
       - Ne pas dupliquer dans le parent (sinon on interfÃ©rerait avec lâ€™entrÃ©e/sortie du shell).  
       - Stocker le `pid` de lâ€™enfant (p.ex. dans un tableau `pids[i]`) pour pouvoir attendre plus tard.  
       - **Ne pas attendre tout de suite** : on continue de crÃ©er le pipeline sans attendre chaque commande individuellement. (Attendre ici bloquerait le parent trop tÃ´t.)  
   - RÃ©pÃ©ter jusquâ€™Ã  la derniÃ¨re commande.  

3. **Fermer les pipes dans le parent** : une fois tous les enfants lancÃ©s, le processus parent (le shell) ferme **toutes** les extrÃ©mitÃ©s de pipe quâ€™il possÃ¨de encore. En effet, il nâ€™en a plus besoin (les enfants ont leurs propres copies pour communiquer). Fermer permet aussi aux enfants en lecture de recevoir un EOF quand le processus en Ã©criture termine.  

4. **Attendre les enfants** : le parent appelle `waitpid` sur chaque PID stockÃ© pour sâ€™assurer que tous les processus du pipeline sont terminÃ©s avant de retourner Ã  lâ€™invite. Câ€™est Ã  ce moment quâ€™on peut dÃ©terminer le code de retour du pipeline : par convention POSIX, câ€™est le code de sortie de la **derniÃ¨re** commande de la chaÃ®ne qui est repris dans `$?`. Il faut donc conserver le status du dernier `waitpid` (ou filtrer par pid) et mettre Ã  jour `$?` avec `WEXITSTATUS(status_last)`. Tous les enfants doivent Ãªtre *wait*, sinon ils deviendraient des processus zombies.  

En code C, cela peut donner une structure gÃ©nÃ©rale comme ci-dessousÂ :

```c
int execute_pipeline(char ***cmds, int cmd_count, char **envp) {
    int pipes[PIPE_MAX][2];                // PIPE_MAX = cmd_count - 1
    pid_t pids[PROCESS_MAX];
    int status = 0;

    // 1. CrÃ©er pipes
    for (int i = 0; i < cmd_count - 1; ++i) {
        if (pipe(pipes[i]) < 0) {
            perror("minishell: pipe");
            return 1; // code erreur shell
        }
    }

    // 2. Lancer chaque commande
    for (int i = 0; i < cmd_count; ++i) {
        pids[i] = fork();
        if (pids[i] < 0) {
            perror("minishell: fork");
            return 1;
        }
        if (pids[i] == 0) {  // Enfant
            // Redirections de pipe en entrÃ©e
            if (i > 0) {
                dup2(pipes[i-1][0], STDIN_FILENO);
            }
            // Redirections de pipe en sortie
            if (i < cmd_count - 1) {
                dup2(pipes[i][1], STDOUT_FILENO);
            }
            // Fermer tous les pipes dans l'enfant
            for (int j = 0; j < cmd_count - 1; ++j) {
                close(pipes[j][0]);
                close(pipes[j][1]);
            }
            // ExÃ©cuter la commande (built-in ou externe)
            execve(cmds[i][0], cmds[i], envp);
            // Si on arrive ici, execve a Ã©chouÃ©
            fprintf(stderr, "minishell: %s: %s\n", cmds[i][0], strerror(errno));
            _exit((errno == ENOENT) ? 127 : 126);  // 127=commande non trouvÃ©e, 126=impossible d'exÃ©cuter
        }
        // Parent: on ne redirige pas, on continue la boucle
    }

    // 3. Fermer toutes les extrÃ©mitÃ©s de pipes dans le parent
    for (int i = 0; i < cmd_count - 1; ++i) {
        close(pipes[i][0]);
        close(pipes[i][1]);
    }

    // 4. Attendre tous les enfants
    int exit_code = 0;
    for (int i = 0; i < cmd_count; ++i) {
        waitpid(pids[i], &status, 0);
        if (i == cmd_count - 1) { 
            // Conserver le code de la derniÃ¨re commande
            if (WIFEXITED(status))
                exit_code = WEXITSTATUS(status);
            else if (WIFSIGNALED(status))
                exit_code = 128 + WTERMSIG(status);  // convention: 128+signal
        }
    }
    return exit_code;
}
```

Dans cet exemple, `cmds` est un tableau de commandes, chaque commande Ã©tant un tableau de chaÃ®nes (le nom de lâ€™exÃ©cutable suivi de ses arguments, terminÃ© par NULL). Le code crÃ©e les pipes, duplique les FDs appropriÃ©s, exÃ©cute les commandes, puis attend. On fait attention Ã  : 

- **Placer les `dup2` juste avant le `execve`** dans lâ€™enfant, afin que chaque processus nâ€™ait que ses FDs nÃ©cessaires.  
- **Fermer les descripteurs** de pipe dans tous les processus oÃ¹ ils ne servent pas, pour Ã©viter les bloquants (un `close` dans le parent est crucial pour que lâ€™enfant lecteur voie lâ€™EOF quand le dernier Ã©crivain se termine).  
- **Ne pas attendre trop tÃ´t** : on attend tous ensemble Ã  la fin, pas aprÃ¨s chaque fork individuel.  

**Conseil dâ€™optimisationÂ :** On limite le nombre de forks au strict nÃ©cessaire : idÃ©alement, un fork par commande du pipeline. Ã‰vitez de *fork* deux fois pour une mÃªme commande (par exemple, ne pas fork dans une fonction dâ€™exec puis refork ailleurs), sinon vous doublez le nombre de processus sans raison. De mÃªme, ne **forkez pas** du tout pour exÃ©cuter le pipeline dans le processus parent lui-mÃªme (un â€œsubshellâ€ global) â€“ cela complexifie la rÃ©cupÃ©ration du code de retour et nâ€™est pas nÃ©cessaire ici (on peut tout lancer directement depuis le shell courant en forÃ§ant lâ€™attente des enfants ensuite).  

En suivant ces Ã©tapes, on obtient une exÃ©cution pipelinÃ©e correcte : le shell attend la fin complÃ¨te de la pipeline avant de redonner la main, et les commandes peuvent tourner en parallÃ¨le.  

## 2. Redirections (`<`, `>`, `>>`)  

### 2.1 ThÃ©orie des redirections dâ€™entrÃ©es/sorties  
Les **redirections** permettent de changer les sources et destinations par dÃ©faut des donnÃ©es dâ€™un programme. Par dÃ©faut, un processus lit sur lâ€™entrÃ©e standard (clavier ou pipe) et Ã©crit sur la sortie standard (terminal ou pipe). En Bash, avec lâ€™opÃ©rateur `<` on peut **remplacer lâ€™entrÃ©e standard** dâ€™une commande par le contenu dâ€™un fichier, et avec `>` ou `>>` on peut **rediriger la sortie standard** vers un fichier (en Ã©crasant ou en ajoutant Ã  la fin). 

- `commande < fichier` : la commande lira les donnÃ©es du fichier Ã  la place du clavier. Câ€™est comme **verser le contenu du fichier dans la commande**. (AnalogieÂ : *brancher* un fichier sur lâ€™entrÃ©e de la commande, comme si on collait le fichier au lieu de taper au clavier.)  
- `commande > fichier` : la sortie de la commande (ce quâ€™elle afficherait Ã  lâ€™Ã©cran) est envoyÃ©e dans `fichier`. **`>` crÃ©e ou Ã©crase** le fichier. (AnalogieÂ : on oriente le flux de sortie vers un seau/fichier au lieu de le laisser couler Ã  lâ€™Ã©cran.)  
- `commande >> fichier` : similaire Ã  `>`, mais **ajoute Ã  la fin** du fichier au lieu dâ€™Ã©craser. (AnalogieÂ : on ajoute de lâ€™eau au seau sans vider ce quâ€™il contient dÃ©jÃ .)  

On peut combiner plusieurs redirections sur une mÃªme commande, par exemple : `commande < in.txt >> out.txt`. Cela signifie *â€œprends in.txt en entrÃ©e, exÃ©cute la commande, et ajoute la sortie Ã  out.txtâ€*. Bash permet plusieurs redirections sur la mÃªme ligne, traitÃ©es **de gauche Ã  droite**. Cependant, **chaque descripteur ne peut Ãªtre redirigÃ© quâ€™une seule fois effectue**. ConcrÃ¨tement, rediriger deux fois la sortie standard dans la mÃªme commande revient Ã  ce que **seule la derniÃ¨re redirection sâ€™applique** (les prÃ©cÃ©dentes sont quand mÃªme Ã©valuÃ©es, crÃ©ant/tronquant des fichiers, mais elles sont ensuite remplacÃ©es). Par exemple, `ls >file1 >file2` crÃ©era (ou videra) `file1`, puis redirigera finalement la sortie vers `file2` (qui recevra le listing). En gÃ©nÃ©ral, en script, on Ã©vite de rediriger deux fois le mÃªme flux, sauf Ã  utiliser des astuces avec `tee` ou autres.  

### 2.2 ImplÃ©mentation des redirections en C  
Dans le parsing de Minishell, les symboles `<`, `>` et `>>` seront dÃ©tectÃ©s comme des opÃ©rateurs de redirection suivis dâ€™un nom de fichier (le *path* cible ou source). Lâ€™implÃ©mentation consiste Ã  :  

- **Identifier les redirections** prÃ©sentes dans la commande (parsing prÃ©alable).  
- **Ouvrir les fichiers** correspondants avec les bons modes (lecture ou Ã©criture, et avec crÃ©ation/append selon le cas).  
- **Assigner les descripteurs** de fichiers obtenus Ã  `STDIN_FILENO` ou `STDOUT_FILENO` au bon moment grÃ¢ce Ã  `dup2()`, afin que lâ€™exÃ©cution de la commande lise/Ã©crive au bon endroit.  
- **GÃ©rer les erreurs** dâ€™ouverture/duplication en se conformant aux messages dâ€™erreur Bash et aux codes de retour.  

**Ouverture des fichiers** (`open`) :  

- Pour `< fichier` (redirection dâ€™entrÃ©e) : on ouvre le fichier en lecture seule (`O_RDONLY`). Si lâ€™ouverture Ã©choue (fichier inexistant par ex.), on affichera lâ€™erreur *â€œminishell: fichier: No such file or directoryâ€* et on ne lancera pas la commande (code de retour 1 ou 127 selon le contexte Bash).  
- Pour `> fichier` (redirection de sortie, Ã©crasement) : on ouvre le fichier en Ã©criture avec les flags `O_CREAT | O_TRUNC | O_WRONLY`. `O_CREAT` crÃ©e le fichier sâ€™il nâ€™existe pas, `O_TRUNC` le vide sâ€™il existe. Il faut aussi passer un mode (droits) lors de la crÃ©ation, par ex. `0644` (rw-r--r--).  
- Pour `>> fichier` (redirection de sortie en append) : flags `O_CREAT | O_APPEND | O_WRONLY`. Sâ€™il nâ€™existe pas, on le crÃ©e; sâ€™il existe on *nâ€™efface pas*, lâ€™Ã©criture se fera Ã  la fin.  

Chaque `open()` retourne un descripteur de fichier (entier >= 0) en cas de succÃ¨s, ou -1 en cas dâ€™erreur (errno est alors positionnÃ©). Important : si plusieurs redirections de mÃªme type sâ€™enchaÃ®nent, on peut trÃ¨s bien ouvrir plusieurs fichiers, mais **seul le dernier sera finalement utilisÃ©**. On peut implÃ©menter cela en stockant le dernier fd ouvert pour lâ€™entrÃ©e et la sortie, et en fermant les prÃ©cÃ©dents non utilisÃ©s immÃ©diatement, ou simplement en les remplaÃ§ant au fur et Ã  mesure.  

**Duplication vers stdin/stdout** : une fois les fichiers ouverts, juste avant dâ€™exÃ©cuter la commande (ou dâ€™appeler la fonction built-in), on utilise `dup2()` :  

- Si un fichier dâ€™entrÃ©e a Ã©tÃ© ouvert (redir `<`), on fait `dup2(fd_in, STDIN_FILENO)`. AprÃ¨s cela, toute lecture via `stdin` (des fonctions comme `read()` ou `get_next_line()` de la commande) lira dans le fichier.  
- Si un fichier de sortie a Ã©tÃ© ouvert (redir `>` ou `>>`), on fait `dup2(fd_out, STDOUT_FILENO)`. Toute Ã©criture vers `stdout` ira dans le fichier.  

On peut ensuite fermer les `fd_in`/`fd_out` dâ€™origine, car `dup2` a duplicatÃ© les FDs vers 0 ou 1.  

**Quand effectuer ces `dup2`Â ?**  
- Si la commande est exÃ©cutÃ©e dans un processus enfant (cas gÃ©nÃ©ral, ou dans un pipeline), on fait ces duplications dans lâ€™enfant avant le `execve`.  
- Si câ€™est une commande *built-in* exÃ©cutÃ©e directement dans le processus principal du shell (sans fork, hors pipeline), il faut faire attention : il faut rediriger lâ€™IO du shell, exÃ©cuter la fonction, puis **restaurer les descripteurs dâ€™origine** aprÃ¨s coup (sinon le shell lui-mÃªme perd son STDOUT/STDIN normal pour la suite). On peut sauvegarder `int saved_stdin = dup(0)` et `int saved_stdout = dup(1)` avant de rediriger, puis aprÃ¨s exÃ©cution de la built-in, restaurer avec `dup2(saved_stdin, 0)` et `dup2(saved_stdout, 1)`.  

**Exemple dâ€™implÃ©mentation** : Supposons une structure de commande parse contenant deux champs optionnels `infile` et `outfile` (NULL sâ€™il nâ€™y en a pas, ou contenant le chemin du fichier, et un flag pour diffÃ©rencier `>`/`>>` pour outfile). On peut avoir une fonction `setup_redirections(cmd)` qui retourne -1 en cas dâ€™erreur, 0 en succÃ¨s :  

```c
int setup_redirections(t_cmd *cmd) {
    int fd;
    // Redirection dâ€™entrÃ©e
    if (cmd->infile) {
        fd = open(cmd->infile, O_RDONLY);
        if (fd < 0) {
            fprintf(stderr, "minishell: %s: %s\n", cmd->infile, strerror(errno));
            return -1; // Indique erreur, on ne doit pas exec la commande
        }
        dup2(fd, STDIN_FILENO);
        close(fd);
    }
    // Redirection de sortie
    if (cmd->outfile) {
        int flags = O_CREAT | O_WRONLY;
        if (cmd->append) {            // append mode '>>'
            flags |= O_APPEND;
        } else {                     // overwrite mode '>'
            flags |= O_TRUNC;
        }
        fd = open(cmd->outfile, flags, 0644);
        if (fd < 0) {
            fprintf(stderr, "minishell: %s: %s\n", cmd->outfile, strerror(errno));
            return -1;
        }
        dup2(fd, STDOUT_FILENO);
        close(fd);
    }
    return 0;
}
```

On appellerait cette fonction dans lâ€™enfant (ou avant lâ€™appel de la built-in) pour appliquer les redirections. Si une erreur survient, on affichera le message dâ€™erreur (formatÃ© `minishell: fichier: message`) et on sortira sans exÃ©cuter la commande.  

**Gestion des messages dâ€™erreur** : On utilise `strerror(errno)` pour traduire le code dâ€™erreur en message lisible (â€œNo such file or directoryâ€, â€œPermission deniedâ€, etc.). Bash inclut le nom de la commande ou du shell en prÃ©fixe, par exemple `bash: fichier: error`. Dans notre shell, on peut prÃ©fixer par `minishell:` pour indiquer la provenance. Veillez Ã  bien reproduire les messages dâ€™erreurs spÃ©cifiques :  

- Fichier introuvable en entrÃ©e : `minishell: fichier: No such file or directory` (errno=ENOENT).  
- Permission refusÃ©e (par ex essayer dâ€™ouvrir un dossier ou un fichier non autorisÃ© en Ã©criture) : `minishell: fichier: Permission denied` (errno=EACCES).  
- Sâ€™il y a une erreur sur plusieurs redirections, Bash affiche seulement la premiÃ¨re rencontrÃ©e en lisant de gauche Ã  droite. Par exemple `cat < nofile1 < nofile2` affichera lâ€™erreur pour `nofile1` puis ne tentera pas `nofile2`. On peut reproduire ce comportement en arrÃªtant dÃ¨s la premiÃ¨re erreur rencontrÃ©e lors du setup des redirections.  

**Combinaisons de redirections** : On peut avoir Ã  la fois une redirection dâ€™entrÃ©e *et* de sortie sur la mÃªme commande. Lâ€™ordre importe (gauche Ã  droite) pour lâ€™ouverture, mais finalement on peut ouvrir input puis output (ou vice versa). Lâ€™important est de faire tous les `open` **avant** le `execve` ou lâ€™exÃ©cution de la commande. Dans lâ€™exemple ci-dessus, on gÃ¨re `infile` puis `outfile`. Si jamais il y avait plusieurs redir output (ex `cmd > out1 > out2`), notre structure stockerait probablement seulement la derniÃ¨re (`outfile = "out2"`, en ayant ignorÃ© ou Ã©crasÃ© "out1"). Alternativement, on pourrait stocker les deux et appliquer en sÃ©quence â€“ dans ce cas il faudrait ouvrir out1 (ce qui vide/crÃ©e le fichier) puis out2 qui prend le dessus. Lâ€™approche la plus simple est de **remplacer directement** la prÃ©cÃ©dente redirection du mÃªme type lors du parsing : ainsi `outfile` ne contiendra que la derniÃ¨re cible utile, ce qui Ã©vite du travail inutile.  

**Redirections et pipelines** : Il faut conjuguer ces mÃ©canismes. Lorsquâ€™une commande a des redirections et est aussi reliÃ©e par un pipe, les duplications de descripteurs sâ€™additionnent : par exemple, pour une commande du milieu dâ€™un pipeline ayant `< input.txt`, on devra dupliquer `input.txt` sur STDIN *puis* dupliquer le pipe sortie sur STDOUT. On peut faire `setup_redirections(cmd)` puis faire le `dup2` du pipe pour STDOUT, ou inversement. **Attention** : lâ€™ordre de dup2 importe seulement sâ€™il y a collision de descripteurs. Pour Ãªtre sÃ»r, on peut dâ€™abord rediriger les fichiers (ce qui utilise 0 ou 1), puis rediriger les pipes (ce qui rÃ©Ã©crase Ã©ventuellement STDIN/STDOUT). Mais il vaut mieux rÃ©flÃ©chir : si on duplique dâ€™abord le pipe sur STDOUT puis on duplique un fichier sortie sur STDOUT, le pipe sera perdu. Donc lâ€™ordre doit respecter la commande : *le dernier qui doit prendre effet sur STDOUT doit Ãªtre fait en dernier*. Ã‰tant donnÃ© que la sÃ©mantique Bash est gauche-droite, on peut appliquer dup2 dans cet ordre. Par exemple `cmd < in1 < in2 > out1 >> out2` : Bash va finalement utiliser `in2` et `out2`. On pourrait donc ouvrir in1 (erreur ou pas), puis in2 (prend le relais), puis out1 (ouvre/tronque, mais sera supplantÃ©), puis out2. Enfin on dup2 in2 sur 0 et out2 sur 1. Pour simplifier, on aura stockÃ© directement infile = "in2", outfile="out2" avec append=1, et on fait juste ces deux dup2.  

En rÃ©sumÃ©, lâ€™implÃ©mentation doit : analyser et conserver la bonne redirection finale pour chaque flux, ouvrir les fichiers concernÃ©s avec `open`, effectuer `dup2` pour brancher les flux, et bien gÃ©rer les erreurs (messages + arrÃªter lâ€™exÃ©cution de la commande en erreur). Testez tous les cas (fichier qui existe/pas, droits, combinaisons).  

## 3. Here-documents (`<<`)  

### 3.1 Quâ€™est-ce quâ€™un here-document ?  
Un **here-document** est un mÃ©canisme qui permet de fournir Ã  une commande un *bloc de texte multi-lignes* en entrÃ©e, directement dans le script, sans passer par un fichier temporaire explicite. En syntaxe shell, on utilise lâ€™opÃ©rateur `<<` suivi dâ€™un **dÃ©limiteur** (un mot marqueur). Le shell lira ensuite tout ce qui est tapÃ© **jusquâ€™Ã  rencontrer une ligne contenant uniquement ce dÃ©limiteur**, et tout ce texte sera fourni Ã  la commande via son entrÃ©e standard. Exemple : 

```bash
cat <<EOF
Hello
World
EOF
```  

Ici, la commande `cat` va recevoir deux lignes "Hello" et "World" puis un EOF. Ce bloc de texte entre `<<EOF` et `EOF` sâ€™appelle un here-document.  

**AnalogieÂ :** vous Ã©crivez une lettre (plusieurs lignes) et vous la confiez Ã  la commande comme si câ€™Ã©tait un fichier dâ€™entrÃ©e. Le dÃ©limiteur (`EOF` dans lâ€™exemple) joue le rÃ´le de *Â«Â fin de la lettreÂ Â»*.  

Quelques dÃ©tails importants du comportement (hÃ©ritÃ©s de Bash)Â :  

- Le dÃ©limiteur peut Ãªtre nâ€™importe quel mot. Par convention on utilise souvent `EOF`, mais Ã§a pourrait Ãªtre `FIN`, `STOP` etc. Il doit apparaÃ®tre seul sur sa ligne de fin pour clÃ´turer le here-doc.  
- **Pas dâ€™inclusion du dÃ©limiteur** : les lignes du here-doc *nâ€™incluent pas* la ligne marquant la fin. Autrement dit, dans lâ€™exemple, `cat` recevra "Hello\nWorld\n" et pas "EOF".  
- On peut **imbriquer** un here-doc dans une pipeline ou avec dâ€™autres redirections. Ex: `cmd1 <<EOF | cmd2` est valide (le here-doc fournit lâ€™entrÃ©e de cmd1, dont la sortie part en pipe vers cmd2).  

**Expansion des variables** : câ€™est un point crucial. Par dÃ©faut, Bash va effectuer lâ€™expansion des variables **dans le contenu du here-document**, exactement comme sâ€™il sâ€™agissait dâ€™un texte dâ€™entrÃ©e normal, *sauf* si le dÃ©limiteur est **entre guillemets** (simples ou doubles). RÃ¨gle : 

- Si le dÃ©limiteur nâ€™est pas quoted (pas de guillemets autour), alors **toutes les expansions sont effectuÃ©es** dans le texte du here-doc (variables `$VAR`, substitution de commande `` `cmd` `` etc.) avant de le donner Ã  la commande.  
- Si le dÃ©limiteur est **entre quotes** (par ex `<< "EOF"` ou `<< 'FIN'`), alors **aucune expansion nâ€™est faite** dans le contenu : on prend le texte tel quel (les `$` restent littÃ©raux).  

Cette nuance permet dâ€™inclure du texte brut comportant des `$` ou autres sans quâ€™ils soient interprÃ©tÃ©s. Par exemple : 

```bash
VAR=42
cat <<EOF
La valeur est $VAR
EOF
```  
affichera *â€œLa valeur est 42â€* car `$VAR` sera substituÃ©. Tandis que : 

```bash
cat << "EOF"
La valeur est $VAR
EOF
```  
affichera littÃ©ralement *â€œLa valeur est $VARâ€* (pas dâ€™expansion, car le dÃ©limiteur `"EOF"` est quoted).  

Dans Minishell, il faut implÃ©menter ce comportement pour Ãªtre cohÃ©rent avec Bash. **Oui, lâ€™expansion dans les here-doc est nÃ©cessaire** (sauf dÃ©limiteur quotes qui lâ€™annule). 

### 3.2 ImplÃ©mentation du here-doc dans Minishell  
**Approche gÃ©nÃ©rale** : Lorsquâ€™on dÃ©tecte un token `<< DELIM` dans la ligne de commande, on va devoir :  

1. Lire interactivement (ou depuis lâ€™input script) toutes les lignes jusquâ€™Ã  une ligne Ã©gale au dÃ©limiteur `DELIM`.  
2. Stocker ces lignes quelque part (en mÃ©moire ou dans un fichier temporaire).  
3. Fournir ces lignes Ã  la commande ciblÃ©e comme entrÃ©e standard.  

Lâ€™implÃ©mentation typique en C utilise un tube (*pipe*) ou un fichier temporaire pour stocker les donnÃ©es du here-doc :  

- **Option pipe (courant dans Minishell)** : On crÃ©e un `pipe()` dÃ¨s quâ€™on rencontre le here-doc. On lit toutes les lignes du here-doc, on les Ã©crit dans lâ€™extrÃ©mitÃ© en Ã©criture du pipe, puis on la ferme. Ainsi, lâ€™extrÃ©mitÃ© en lecture du pipe contient tout le texte et pourra Ãªtre dupliquÃ©e sur lâ€™entrÃ©e standard de la commande. Cette mÃ©thode Ã©vite de crÃ©er un fichier sur le disque, tout se fait en mÃ©moire (via le pipe).  
- Option fichier temporaire : ouvrir un `tmpfile` ou un fichier genre `/tmp/sh-heredoc-xxxxx`, y Ã©crire les lignes, puis le rouvrir en lecture pour dup sur STDIN. Câ€™est aussi faisable (Bash utilise en interne un fichier anonyme). Mais dans Minishell on peut se contenter dâ€™un pipe pour plus de simplicitÃ©.  

**Lecture du here-doc** : On peut utiliser `readline()` (ou `get_next_line()` si pas de readline) en affichant un prompt spÃ©cial (par ex. `> ` comme Bash, ou rien). On lit ligne par ligne : 

- Si la ligne est **NULL** (EOF inattendu, par ex. user a fait `Ctrl+D`), on arrÃªte la lecture. Bash dans ce cas affiche un message du type `warning: here-document at line X delimited by end-of-file (wanted 'DELIM')`. On peut gÃ©rer Ã§a en interne (non obligatoire pour le projet, mais possible).  
- Ã€ chaque ligne lue, on la compare au dÃ©limiteur cible : si elle est exactement Ã©gale (en tenant compte quâ€™en gÃ©nÃ©ral le dÃ©limiteur ne doit pas inclure le `\n` final), alors on **stoppe** la collecte (ne pas inclure cette ligne).  
- Sinon, la ligne fait partie du here-doc : on lui ajoute un `\n` (car readline retourne sans le sÃ©parateur de ligne), puis on lâ€™Ã©crit dans le pipe/fichier temporaire. Avant dâ€™Ã©crire, on doit Ã©ventuellement faire lâ€™**expansion** des variables **si** le dÃ©limiteur nâ€™Ã©tait pas quoted. Pour cela, il faut parcourir la ligne et remplacer les occurrences de `$variable` par leur valeur (utiliser la liste chaÃ®nÃ©e dâ€™environnement, etc.), et `$?` par le code de sortie prÃ©cÃ©dent. On peut rÃ©utiliser la logique dâ€™expansion dÃ©jÃ  codÃ©e pour lâ€™analyse des commandes normales. Si le dÃ©limiteur Ã©tait quoted, on nâ€™effectue aucune substitution (utiliser un boolÃ©en `expand` calculÃ© lors du parsing : `expand = (delimiter_not_quoted)`).  

Une fois la lecture terminÃ©e (dÃ©limiteur trouvÃ© ou EOF), on ferme lâ€™Ã©criture du pipe. Ã€ ce stade, lâ€™extrÃ©mitÃ© en lecture du pipe contient tout le texte du here-doc, prÃªt Ã  Ãªtre lu.  

**IntÃ©gration dans lâ€™exÃ©cution** : Maintenant, comment lâ€™utiliser lors de lâ€™exec ? Si la commande est dans un pipeline ou un fork sÃ©parÃ©, il suffit dans le processus enfant (avant execve) de faire `dup2(pipe_read_fd, STDIN_FILENO)` pour que la commande lise dans le pipe. Si la commande nâ€™est pas forkÃ©e (built-in dans parent), il faudra dup2 sur STDIN dans le parent, exÃ©cuter le built-in, puis restaurer STDIN (mÃ©canisme similaire aux redirections classiques).  

**Exemple** : `grep "hello" <<EOF > out.txt ... EOF`. On aurait : une redirection here-doc et une redirection de sortie. ConcrÃ¨tement :  
- Lire tout le here-doc "EOF" dans un pipe (mettons fd_pipe[0] en lecture, fd_pipe[1] en Ã©criture).  
- Ouvrir `out.txt` en Ã©criture (via `open`).  
- Forker le processus pour `grep` (si pipeline). Dans lâ€™enfant, faire `dup2(fd_pipe[0], STDIN_FILENO)` pour brancher lâ€™entrÃ©e sur le here-doc, et `dup2(fd_out, STDOUT_FILENO)` pour la sortie vers fichier. Fermer les fd. Puis `execve("grep", ["grep", "hello", NULL], envp)`.  
- Dans le parent, fermer fd_pipe[0] et fd_pipe[1] aprÃ¨s Ã©criture du here-doc, fermer fd_out, attendre lâ€™enfant.  

**Code illustratif** : voici une fonction simplifiÃ©e qui lit un here-doc (sans le contexte complet du shell) : 

```c
int create_heredoc_pipe(const char *delimiter, int expand, t_env *env, int *heredoc_fd) {
    int pipe_fd[2];
    if (pipe(pipe_fd) < 0) {
        perror("minishell: pipe");
        return -1;
    }
    char *line;
    while (1) {
        line = readline("> ");  // prompt du here-doc
        if (!line) {
            // EOF (Ctrl+D) - stopper
            break;
        }
        if (strcmp(line, delimiter) == 0) {
            free(line);
            break;  // fin du here-doc
        }
        char *expanded_line = line;
        if (expand) {
            expanded_line = expand_variables(line, env);
            // expand_variables: fonction Ã  implÃ©menter sÃ©parÃ©ment
        }
        write(pipe_fd[1], expanded_line, strlen(expanded_line));
        write(pipe_fd[1], "\n", 1);
        if (expanded_line != line)
            free(expanded_line);
        free(line);
    }
    close(pipe_fd[1]);      // on ferme l'Ã©criture, prÃªt Ã  lire
    *heredoc_fd = pipe_fd[0];
    return 0;
}
``` 

Ici, `expand` est un boolÃ©en indiquant si on doit faire lâ€™expansion (donc si le dÃ©limiteur nâ€™Ã©tait pas entourÃ© de quotes lors du parsing). `t_env *env` reprÃ©sente la liste des variables dâ€™environnement (pour chercher les valeurs de `$VAR`). La fonction renvoie le fd de lecture du pipe via `heredoc_fd`. Le `readline("> ")` affiche `>` comme Bash le fait en PS2 prompt pour indiquer une continuation.  

Il faudra appeler `create_heredoc_pipe` au bon moment : typiquement *avant* de forker/exec la commande associÃ©e, pour obtenir le fd. En pratique, on peut lors du parsing repÃ©rer tous les here-docs prÃ©sents dans la ligne (il peut y en avoir plusieurs successifs ou dans des sous-commandes) et les traiter tout de suite pour Ã©viter dâ€™avoir Ã  gÃ©rer la lecture asynchrone aprÃ¨s un fork (car la gestion du `readline` et des signaux est plus facile dans le processus principal). Par exemple, pour chaque here-doc rencontrÃ©, on peut gÃ©nÃ©rer un fd temporaire et stocker-le dans la structure de la commande comme son `heredoc_fd`. Ensuite, dans lâ€™exÃ©cution, si `heredoc_fd` est valide, on fera simplement `dup2(heredoc_fd, STDIN_FILENO)` comme si câ€™Ã©tait un fichier dâ€™entrÃ©e normal, puis close.  

**Gestion des signaux** : En mode here-doc interactif, si lâ€™utilisateur tape `Ctrl+C`, Bash annule le here-doc (on obtient une nouvelle invite normale, et la commande liÃ©e nâ€™est pas exÃ©cutÃ©e). Cela implique dâ€™attraper SIGINT pendant la lecture du here-doc. On peut configurer le handler de SIGINT diffÃ©remment lorsquâ€™on est dans la boucle de here-doc : par exemple, si SIGINT, on ferme le pipe et on retourne une indication dâ€™abandon. Il y a un certain dÃ©tail Ã  implÃ©menter, mais mentionnons-le : il faudra peut-Ãªtre ignorer le reste du here-doc et laisser la commande avortÃ©e (Bash imprime rien de spÃ©cial sauf revenir prompt).  

En rÃ©sumÃ©, lâ€™implÃ©mentation dâ€™un here-doc dans Minishell consiste Ã  lire toutes les lignes jusquâ€™au dÃ©limiteur dans un pipe (en respectant la rÃ¨gle dâ€™expansion des variables ou non), puis Ã  rediriger lâ€™entrÃ©e standard de la commande vers ce pipe. Pour le projet Minishell, veillez Ã  bien suivre la spÃ©cification : par exemple, le sujet 42 demande souvent de **ne pas Ã©tendre les variables dans le here-doc si le dÃ©limiteur est entre guillemets**, ce quâ€™on a couvert. Testez avec diffÃ©rentes valeurs de `$?`, de `$VAR` dÃ©finies ou non, avec ou sans quotes autour du dÃ©limiteur.  

## 4. ImplÃ©mentation des built-ins (`echo`, `cd`, `pwd`, `export`, `unset`, `env`, `exit`)  

Les *built-ins* sont des commandes **interprÃ©tÃ©es directement par le shell**, sans passer par un exÃ©cutable externe. On les implÃ©mente donc en C dans notre programme, et on les appelle de maniÃ¨re spÃ©cifique lorsquâ€™elles sont invoquÃ©es. Les built-ins Ã  coder sont : **`echo`**, **`cd`**, **`pwd`**, **`export`**, **`unset`**, **`env`**, **`exit`**.  

**Pourquoi des built-ins ?** Certaines de ces commandes doivent pouvoir modifier lâ€™Ã©tat interne du shell (par ex `cd` change le rÃ©pertoire courant du processus shell lui-mÃªme, `export` modifie les variables dâ€™environnement du shell). On ne peut pas toujours les lancer dans un `execve` sÃ©parÃ©, sinon ces modifications seraient perdues une fois le processus child terminÃ©. Câ€™est pourquoi le shell les implÃ©mente en interne. Dâ€™autres (comme `echo` ou `env`) pourraient techniquement Ãªtre des externes, mais on les implÃ©mente quand mÃªme pour Ãªtre fidÃ¨le au projet ou pour accÃ©lÃ©rer lâ€™exÃ©cution.  

En rÃ¨gle gÃ©nÃ©rale, on exÃ©cutera une built-in **dans le processus parent** shell, sauf si elle fait partie dâ€™un pipeline. Par exemple, pour `echo` seul, on peut Ã©viter de fork et juste imprimer; mais pour `echo` dans un pipeline (`echo hello | grep h`), on devra la lancer dans un child comme un externe pour ne pas bloquer le shell (câ€™est un choix dâ€™implÃ©mentation pour coller au comportement concurrent). Un compromis est de toujours forker les pipelines y compris les built-ins, mais de ne pas forker quand une built-in est seule (optimisation).  

Passons en revue chaque built-in avec son comportement et une implÃ©mentation minimaliste :  

### 4.1 Built-in `echo`  
**Fonction** : Affiche ses arguments sÃ©parÃ©s par des espaces, suivi par un saut de ligne, sur la sortie standard. Supporte lâ€™option `-n` pour *ne pas* ajouter de saut de ligne final.  

- Sans option, `echo arg1 arg2` affichera `arg1 arg2` suivi dâ€™un retour Ã  la ligne.  
- Avec `-n`, ex: `echo -n "Hello"` affichera `Hello` **sans** retour Ã  la ligne (le prompt viendra Ã  la suite sur la mÃªme ligne). On peut avoir plusieurs `-n` consÃ©cutifs, Bash les traite tous comme lâ€™option (tous sauf `-n` sont considÃ©rÃ©s texte Ã  afficher).  

**ImplÃ©mentation** : on peut parse `argv` de la fonction echo en C, et dÃ©tecter lâ€™option. Une subtilitÃ© du projet 42 Minishell : souvent ils demandent de gÃ©rer uniquement `-n` (pas dâ€™autres options dâ€™echo). On considÃ©rera donc que toute combinaison commenÃ§ant par `-n` (exactement `-n` ou `-nnnn`) est une option valide pour â€œpas de newlineâ€.  

```c
int ft_echo(char * const *args) {
    int newline = 1;
    int i = 1;
    // Traiter les options -n multiples
    while (args[i] && strcmp(args[i], "-n") == 0) {
        newline = 0;
        i++;
    }
    // Afficher tous les arguments restants sÃ©parÃ©s par des espaces
    for (; args[i]; ++i) {
        fputs(args[i], stdout);
        if (args[i+1])
            fputc(' ', stdout);
    }
    if (newline)
        fputc('\n', stdout);
    return 0;
}
```  

Ici `args[0]` est "echo", on commence Ã  i=1. On renvoie 0 comme exit status (echo renvoie toujours 0 sauf cas dâ€™erreur improbable de write). Pas de message dâ€™erreur particulier, `echo` ne fait pas dâ€™erreur en soi (si on ne trouve pas lâ€™option on considÃ¨re que câ€™est du texte).  

### 4.2 Built-in `cd` (change directory)  
**Fonction** : Change le rÃ©pertoire de travail courant du shell. En Bash, `cd` a plusieurs rÃ¨gles :  

- `cd <path>` : change vers le chemin indiquÃ© (relatif ou absolu).  
- `cd` sans argument : doit changer vers le **HOME** de lâ€™utilisateur (variable dâ€™env `HOME`). Si `HOME` nâ€™est pas dÃ©fini, Bash affiche une erreur : `bash: cd: HOME not set`.  
- `cd -` : option non requise dans le projet minishell (retour au rÃ©pertoire prÃ©cÃ©dent). Souvent non demandÃ©, on peut ignorer.  

Notre implÃ©mentation utilisera lâ€™appel systÃ¨me **`chdir()`** (man 2 chdir) pour effectuer le changement. `chdir(path)` retourne 0 si succÃ¨s, -1 si erreur (ex : chemin inexistant, pas des droits, etc.). On doit alors gÃ©rer les erreurs : par ex, si le dossier nâ€™existe pas, afficher `minishell: cd: <path>: No such file or directory`. Si câ€™est un fichier et pas un dossier : `Not a directory`.  

Aussi, beaucoup de shells mettent Ã  jour les variables dâ€™environnement `OLDPWD` et `PWD`. Dans Minishell, ce nâ€™est gÃ©nÃ©ralement pas obligatoire de gÃ©rer `OLDPWD`, mais il faut au moins mettre Ã  jour `PWD` pour reflÃ©ter le nouveau rÃ©pertoire courant (pour que lâ€™environnement soit cohÃ©rent avec `getcwd`). Facultatif mais conseillÃ©.  

**ImplÃ©mentation** :  

```c
int ft_cd(char * const *args, t_env *env) {
    const char *path;
    if (!args[1]) {
        // cd sans argument
        path = getenv("HOME");  // ou utiliser env list
        if (!path) {
            fprintf(stderr, "minishell: cd: HOME not set\n");
            return 1;
        }
    } else {
        path = args[1];
    }
    if (chdir(path) != 0) {
        fprintf(stderr, "minishell: cd: %s: %s\n", path, strerror(errno));
        return 1;
    }
    // MÃ j de PWD dans env (facultatif selon projet)
    char cwd[PATH_MAX];
    if (getcwd(cwd, sizeof(cwd))) {
        // update env "PWD" variable
        set_env_value(env, "PWD", cwd);
    }
    return 0;
}
```  

Ici, `t_env *env` serait une structure pour les variables dâ€™environnement. `getenv` peut Ãªtre utilisÃ© si on a exportÃ© envp en global, sinon on parcourra la liste. Note : on utilise `strerror(errno)` pour le message dâ€™erreur. Exemples dâ€™erreurs : si `path` nâ€™existe pas ou est invalide, errno=ENOENT (â€œNo such file or directoryâ€); si câ€™est un fichier, errno=ENOTDIR (â€œNot a directoryâ€); si pas de droits, EACCES (â€œPermission deniedâ€).  

On retourne 1 en cas dâ€™erreur (Bash retourne 1 pour cd failure). Si rÃ©ussite, retourne 0.  

*N.B.* : Le projet Minishell prÃ©cise souvent que `cd` ne doit pas gÃ©rer `-` (ce nâ€™est pas demandÃ©), donc on peut ignorer cette fonctionnalitÃ©.  

### 4.3 Built-in `pwd` (print working directory)  
**Fonction** : Affiche le chemin absolu du rÃ©pertoire courant. En C, on peut utiliser `getcwd(NULL, 0)` (ou `getcwd(buf, size)`). 

- Si succÃ¨s, afficher le chemin suivi dâ€™un saut de ligne.  
- Si Ã©chec (rare, par ex. rÃ©pertoire courant supprimÃ© â€“ cas pathologique), afficher une erreur via `perror("minishell: pwd")` ou un message fixe.  

**ImplÃ©mentation** :  

```c
int ft_pwd(void) {
    char cwd[PATH_MAX];
    if (getcwd(cwd, sizeof(cwd)) == NULL) {
        // getcwd a Ã©chouÃ©
        fprintf(stderr, "minishell: pwd: %s\n", strerror(errno));
        return 1;
    }
    printf("%s\n", cwd);
    return 0;
}
```  

Ici on utilise un buffer statique PATH_MAX (dÃ©fini dans `<limits.h>`). Si on voulait Ãªtre trÃ¨s propre, on pourrait allouer dynamiquement en cas de dÃ©passement, mais ce nâ€™est pas nÃ©cessaire dans ce contexte.  

### 4.4 Built-in `export`  
**Fonction** : En Bash, `export` sert Ã  **marquer des variables dâ€™environnement** pour quâ€™elles soient disponibles aux processus enfants, ou Ã  dÃ©finir de nouvelles variables. Dans Minishell, on va gÃ©rer une liste (ou tableau) de variables dâ€™environnement quâ€™on transporte.  

Usages :  
- `export` sans argument : afficher lâ€™ensemble des variables dâ€™environnement **triÃ©es par ordre alphabÃ©tique**, dans un format spÃ©cifique. Bash affiche avec la syntaxe `declare -x VAR="value"`. Le projet 42 attend gÃ©nÃ©ralement cet affichage formatÃ©. Par exemple, `export` seul pourrait afficher:  
  ```  
  declare -x HOME="/home/user"  
  declare -x PATH="/usr/bin:/bin"  
  declare -x VAR1="foo"  
  declare -x VAR2  
  ```  
  (Note : les variables sans valeur sont affichÃ©es avec juste le nom et pas de `=` ou avec `=""` selon interprÃ©tation â€“ Bash montre `declare -x VAR2=""` si la variable est prÃ©sente mais vide, et `declare -x VAR` sans rien si juste exportÃ© sans valeur *et* pas prÃ©sent dans env? Les subtilitÃ©s de Bash peuvent Ãªtre complexes, mais lâ€™important est dâ€™imiter lâ€™exemple du sujet ou des tests).  
- `export VAR=value` : ajoute ou modifie la variable dâ€™environnement `VAR` avec `value`. Cette variable devient â€œexportÃ©eâ€ (disponible aux futurs execve).  
- `export VAR` : sans `=`, Bash crÃ©e la variable avec valeur vide si elle nâ€™existait pas, ou ne fait rien de plus si elle existe dÃ©jÃ . Câ€™est quand mÃªme considÃ©rÃ© succÃ¨s (on peut la lister).  
- `export VAR+=value` : (bonus) ajouter Ã  la valeur existante (concatenation) â€“ possiblement hors scope du projet.  
- **Erreurs** : si le nom de variable est invalide (ne commence pas par lettre ou `_`, ou contient des caractÃ¨res non autorisÃ©s comme `?` ou `+` hors usage spÃ©cial), Bash affiche `bash: export: 'X': not a valid identifier` et ne change rien pour cet item, retourne code dâ€™erreur 1. (Le projet demande de gÃ©rer ces cas).  

**ImplÃ©mentation** : Il faut manipuler la structure dâ€™environnement interne. Souvent on la reprÃ©sente par une liste chaÃ®nÃ©e de structs { name, value, exported_flag }. Dans Minishell, toutes les variables manipulÃ©es par export/unset/env sont en fait *exportÃ©es* (on peut considÃ©rer quâ€™on gÃ¨re directement lâ€™environnement du processus). On peut donc utiliser `setenv()` du C, mais pour coller au projet on fera manuellement.  

Plan :  
- Si `args[1]` nâ€™existe pas : afficher la liste triÃ©e. Pour trier, on peut rÃ©cupÃ©rer toutes les var dans un tableau, qsort par name, puis imprimer chaque avec `declare -x NAME="VALUE"` (en mettant des guillemets autour de la valeur et en Ã©chappant les Ã©ventuels guillemets spÃ©ciaux si besoin).  
- Sinon, pour chaque argument Ã  partir de 1 :  
  - Valider le format du nom de variable. CrÃ©er une fonction `is_valid_identifier(name)` qui check : premier caractÃ¨re alpha ou `_`, suivants alphanum ou `_`. Ne pas autoriser `=` dans le nom (le `=` sÃ©pare nom/valeur).  
  - DÃ©couper lâ€™argument en nom et valeur : rechercher le premier `=` dans la string. Si prÃ©sent, sÃ©parer le nom et la valeur (valeur = chaÃ®ne aprÃ¨s `=`). Si `=` absent, câ€™est un export sans valeur.  
  - Si nom invalide : afficher `minishell: export: 'ARG': not a valid identifier` (bien mettre les quotes autour de lâ€™argument incriminÃ© comme Bash) et marquer un status dâ€™erreur (on continue Ã  traiter les autres arguments toutefois).  
  - Si valide : mettre Ã  jour la liste dâ€™environnement :  
    - Si la variable nâ€™existe pas, lâ€™ajouter avec la valeur donnÃ©e (ou valeur vide si pas de `=`).  
    - Si elle existe dÃ©jÃ  : si un `=` est prÃ©sent, mettre Ã  jour la valeur. Si câ€™est `VAR+=value`, additionner. (Le cas `+=` est possiblement bonus). Si pas de `=` (juste `export VAR`), on ne modifie pas la valeur existante mais on sâ€™assure que la variable est marquÃ©e exportÃ©e (dans notre shell, par simplicitÃ©, toute variable dans la liste *est* exportÃ©e de base).  
- Retourner 0 si tous les args sont valides, sinon 1 si au moins un Ã©tait invalide (Bash retourne 1 sâ€™il y a eu une erreur sur un identifiant).  

**Code simplifiÃ©** :  

```c
int is_valid_identifier(const char *name) {
    if (!name || !(*name))
        return 0;
    if (!(ft_isalpha(*name) || *name == '_'))
        return 0;
    for (const char *p = name+1; *p; ++p) {
        if (!(ft_isalnum(*p) || *p == '_'))
            return 0;
    }
    return 1;
}

int ft_export(char * const *args, t_env **env_list) {
    if (!args[1]) {
        // Afficher toutes les variables
        t_env *sorted = sort_env_list(*env_list);
        for (t_env *var = sorted; var; var = var->next) {
            printf("declare -x %s", var->name);
            if (var->value) 
                printf("=\"%s\"", var->value);
            printf("\n");
        }
        free_env_list(sorted);
        return 0;
    }
    int ret = 0;
    for (int i = 1; args[i]; ++i) {
        char *arg = args[i];
        char *eq = strchr(arg, '=');
        char name[BUFFER]; 
        if (eq) {
            size_t namelen = eq - arg;
            ft_strlcpy(name, arg, namelen+1);
        } else {
            ft_strlcpy(name, arg, sizeof(name));
        }
        // Handle + in name (VAR+=)
        int append = 0;
        char *plus = strchr(name, '+');
        if (plus && plus[1] == '\0') {
            append = 1;
            *plus = '\0';
        }
        if (!is_valid_identifier(name)) {
            fprintf(stderr, "minishell: export: '%s': not a valid identifier\n", arg);
            ret = 1;
            continue;
        }
        char *value = NULL;
        if (eq) {
            value = eq + 1;
        }
        // Mettre Ã  jour env_list
        t_env *var = find_env(*env_list, name);
        if (!var) {
            env_add(env_list, name, value ? value : "");  // ajoute la variable
        } else {
            if (value) {
                if (append)
                    env_set(var, ft_strjoin(var->value, value));
                else
                    env_set(var, value);
            }
            // si pas de value et var existe, ne rien changer
        }
    }
    return ret;
}
```  

Ce code est un peu long (et utilise des fonctions auxiliaires fictives `sort_env_list`, `env_add`, `env_set` etc.), mais dÃ©crit la logique. Lâ€™essentiel est : valider nom, gÃ©rer crÃ©ation/mise Ã  jour, afficher erreurs au besoin.  

### 4.5 Built-in `unset`  
**Fonction** : Supprime une ou plusieurs variables dâ€™environnement. Syntaxe : `unset VAR1 VAR2 ...`.  

- Pour chaque nom donnÃ©, si la variable existe dans la liste dâ€™env, on la retire (libÃ©rer la mÃ©moire associÃ©e).  
- Si le nom est invalide (mÃªmes rÃ¨gles que export pour un identifiant), Bash affiche `bash: unset: 'X': not a valid identifier` â€“ on fera de mÃªme (`minishell: unset: 'X': not a valid identifier`).  
- Retours : 0 si succÃ¨s total, 1 si au moins une erreur.  

**ImplÃ©mentation** :  

```c
int ft_unset(char * const *args, t_env **env_list) {
    int ret = 0;
    for (int i = 1; args[i]; ++i) {
        if (!is_valid_identifier(args[i])) {
            fprintf(stderr, "minishell: unset: '%s': not a valid identifier\n", args[i]);
            ret = 1;
            continue;
        }
        env_remove(env_list, args[i]);  // supprime la variable nommÃ©e
    }
    return ret;
}
```  

Ici on rÃ©utilise `is_valid_identifier`. Attention, Bash considÃ¨re que `unset` dâ€™une variable inexistante nâ€™est pas une erreur â€“ on fait juste rien (retour 0 si pas dâ€™autres soucis). Notre `env_remove` peut simplement ne rien faire si la var nâ€™est pas trouvÃ©e.  

### 4.6 Built-in `env`  
**Fonction** : Affiche toutes les variables dâ€™environnement **actuelles** (celles avec une valeur, traditionnellement). Dans Bash, `env` sans argument liste lâ€™environnement complet (chaque ligne `VAR=VALUE`).  

Dans Minishell, on peut lâ€™implÃ©menter en affichant toutes les variables stockÃ©es dans notre liste dâ€™env *qui ont une valeur*. Par exemple, une variable juste exportÃ©e sans valeur ne devrait peut-Ãªtre pas sâ€™afficher (Bash nâ€™affiche pas les variables sans valeur dans `env`). On peut choisir de nâ€™afficher que celles dont `value` nâ€™est pas vide, ou dÃ©cider dâ€™afficher toutes (mais alors comment formater sans valeur ? Possiblement juste ne rien mettre aprÃ¨s `=`). La maniÃ¨re courante : **nâ€™afficher que les var ayant une valeur non vide** (exactement comme Bash `env` se base sur lâ€™environnement du processus, qui ne contient pas de var sans valeur).  

**ImplÃ©mentation** :  

```c
int ft_env(t_env *env_list) {
    for (t_env *var = env_list; var; var = var->next) {
        if (var->value) {
            printf("%s=%s\n", var->name, var->value);
        }
    }
    return 0;
}
```  

Ici, on suppose que `env_list` reprÃ©sente lâ€™environnement *exportÃ©* (donc nos variables et leurs valeurs). Les variables sans valeur (valeur NULL ou chaÃ®ne vide) on peut les ignorer.  

### 4.7 Built-in `exit`  
**Fonction** : Ferme le shell. En Bash, `exit [n]` permet de quitter avec le code de retour `n` (0 par dÃ©faut). Dans un shell interactif, Bash affiche `exit` sur la console lorsquâ€™on quitte via la commande (pas via Ctrl+D).  

Cas Ã  gÃ©rer absolument dâ€™aprÃ¨s le projet :  
- `exit` sans argument -> quitter avec code 0. (Et probablement afficher `exit` suivi dâ€™un newline avant de quitter, comme le fait bash interactif).  
- `exit N` avec N un nombre (dans la limite dâ€™un `long long` Ã©ventuellement) -> convertir en entier 8-bit (Bash prend le code modulo 256), quitter avec ce code.  
- `exit arg` oÃ¹ arg nâ€™est pas purement numÃ©rique (par exemple `exit 42abc`) -> Bash affiche une erreur : `bash: exit: 42abc: numeric argument required`, et quitte le shell avec le code **255**. Donc on doit dÃ©tecter si lâ€™argument nâ€™est pas un nombre valide.  
- `exit arg1 arg2` (plus dâ€™un argument) -> Bash : ne quitte pas ! Il affiche `bash: exit: too many arguments`, retourne code 1, et reste dans le shell (donc on ne fait rien dâ€™autre). Ce cas est un peu spÃ©cial car exit ne exit pas rÃ©ellement.  

Lâ€™implÃ©mentation doit donc prendre en compte ces conditions.  

**ImplÃ©mentation** :  

```c
int ft_exit(char * const *args, int interactive) {
    // Si appelÃ© depuis le processus principal interactif, afficher "exit"
    if (interactive)
        fprintf(stderr, "exit\n");
    // Compter les arguments
    int argc = 0;
    while (args[argc])
        argc++;
    if (argc > 2) {
        // Trop d'arguments
        fprintf(stderr, "minishell: exit: too many arguments\n");
        return 1;  // ne pas quitter, juste code dâ€™erreur 1
    }
    long exit_code = 0;
    if (argc == 2) {
        // VÃ©rifier argument numÃ©rique
        char *endptr = NULL;
        exit_code = strtol(args[1], &endptr, 10);
        if (*endptr != '\0') {
            // Pas entiÃ¨rement numÃ©rique
            fprintf(stderr, "minishell: exit: %s: numeric argument required\n", args[1]);
            exit(255);
        }
    }
    // Pas d'erreur, on quitte le programme principal
    exit((unsigned char)exit_code);
}
```  

Ici, `interactive` est un boolÃ©en indiquant si on est dans le shell principal interactif (pour savoir si on doit imprimer "exit"). Dans 42, ils veulent gÃ©nÃ©ralement quâ€™on imprime "exit" quand on quitte via la commande exit, pour faire comme Bash en mode interactif. On lâ€™envoie sur stderr ou stdout ? Bash semble lâ€™afficher sur stdout. On peut mettre sur stdout aussi.  

Lâ€™utilisation de `strtol` permet de dÃ©tecter si la chaÃ®ne nâ€™est pas purement numÃ©rique (endptr ne pointant pas sur fin). On gÃ¨re aussi un dÃ©bordement Ã©ventuel (strtol gÃ¨re longs, si >LLONG_MAX, endptr peut Ãªtre positionnÃ© ou errno=ERANGE). Mais ici Ã§a va.  

- Si plus dâ€™un argument : on affiche lâ€™erreur et on retourne 1 (sans quitter).  
- Si un argument non numÃ©rique : message et on `exit(255)` immÃ©diatement (Bash quitte dans ce cas).  
- Sinon, on convertit et on exit avec `(unsigned char)exit_code` pour obtenir lâ€™Ã©quivalent modulo 256.  

**Important** : Dans le cas oÃ¹ `exit` est appelÃ© dans un *pipeline* ou un *sous-processus* (ex : dans un pipeline ou sous-shell), on ne doit pas quitter le shell principal, juste terminer le processus courant. Dans ce cas, on ne voudra pas appeler `exit()` du programme complet, mais simplement _exit du child avec le code. Donc selon le contexte dâ€™appel (processus parent principal ou un enfant), lâ€™effet diffÃ¨re. Notre `ft_exit` ci-dessus est prÃ©vu pour le parent. Si on dÃ©tecte en amont que la commande est `exit` et que nous sommes dans le processus principal, on peut appeler `ft_exit(args, 1)` pour gÃ©rer la logique et possiblement terminer. Si câ€™est dans un enfant, on peut simplement dÃ©cider de traiter exit comme un cas normal : par ex, dans lâ€™enfant, `ft_exit(args,0)` ferait exit du child.  

### 4.8 IntÃ©gration des built-ins dans le shell  
On peut crÃ©er une fonction routeur du style :  

```c
int exec_builtin(char * const *args, t_env **env, int interactive) {
    if (strcmp(args[0], "echo") == 0)
        return ft_echo(args);
    if (strcmp(args[0], "cd") == 0)
        return ft_cd(args, *env);
    if (strcmp(args[0], "pwd") == 0)
        return ft_pwd();
    if (strcmp(args[0], "export") == 0)
        return ft_export(args, env);
    if (strcmp(args[0], "unset") == 0)
        return ft_unset(args, env);
    if (strcmp(args[0], "env") == 0)
        return ft_env(*env);
    if (strcmp(args[0], "exit") == 0) {
        ft_exit(args, interactive);
        // si ft_exit n'a pas terminÃ© le programme (cas too many args), il a retournÃ© 1
        return 1;
    }
    return -1; // not a builtin
}
```  

Cette fonction tente chaque nom de built-in et appelle la fonction correspondante. Si elle renvoie -1, câ€™est que ce nâ€™est pas un built-in et le shell devra tenter un execve externe.  

**Gestion des erreurs built-in** : La plupart des built-ins retournent 1 en cas dâ€™erreur (ex : mauvais usage, identifiant invalide, etc.), 0 en rÃ©ussite. On doit assigner ces codes Ã  `$?`. On a vu quelques messages dâ€™erreurs spÃ©cifiques : `not a valid identifier` pour export/unset, `HOME not set` pour cd, etc., et on les a implÃ©mentÃ©s.  

**Conseil** : Utilisez la libft pour les opÃ©rations de chaÃ®ne (ft_strncmp, ft_split, ft_isalpha, etc.), Ã§a Ã©vite de rÃ©Ã©crire des fonctions de base et assure la conformitÃ© du projet (puisque libft est autorisÃ©e).  

## 5. CÅ“ur de lâ€™exÃ©cution : coordination avec `execve`  

Nous avons maintenant les briques : pipelines, redirections, here-docs, built-ins. Le cÅ“ur de lâ€™exÃ©cution de Minishell consiste Ã  les orchestrer pour chaque ligne de commande entrÃ©e. Voici le cheminement global lorsque lâ€™utilisateur entre une commande :  

1. **Parsing** : la ligne est dÃ©coupÃ©e en *tokens*, on identifie la structure de la commande : Ã©ventuellement plusieurs commandes sÃ©parÃ©es par `|` (pipeline), des opÃ©rateurs de redirection `<`, `>`â€¦ On organise souvent cela en une structure de donnÃ©es (par ex, une liste chaÃ®nÃ©e ou un arbre syntaxique) de commandes avec leurs arguments et meta-info (infile, outfile, heredoc, etc.).  
2. **ExÃ©cution** : on distingue plusieurs cas : 
   - Si la ligne comporte **plusieurs commandes pipelinÃ©es**, on utilisera la logique de pipeline (section 1) pour les exÃ©cuter en parallÃ¨le. Chaque commande du pipeline, au moment de son fork/exec, devra appliquer ses **redirections** internes (section 2) et eventuellement son **here-doc** (section 3) sur son entrÃ©e. 
   - Si la ligne est une **commande simple** (sans pipe) : on vÃ©rifie si câ€™est un **built-in**.  
     - Si oui, on peut lâ€™exÃ©cuter *dans le processus courant* (sans fork) pour que ses effets persistent. Mais attention Ã  appliquer quand mÃªme les **redirections** : on peut faire comme dit plus haut, dupliquer les fichiers sur STDIN/STDOUT, exÃ©cuter la fonction built-in, puis restaurer. Le code pourrait ressembler Ã  :  
       ```c
       int saved_stdin = dup(0), saved_stdout = dup(1);
       if (setup_redirections(cmd) == 0) {
           status = exec_builtin(cmd->args, &env, /*interactive=*/1);
       } else {
           status = 1; // redirection error
       }
       // Restore original FDs
       dup2(saved_stdin, 0); close(saved_stdin);
       dup2(saved_stdout, 1); close(saved_stdout);
       ```  
       Ici, `status` est le code de retour du built-in ou 1 si erreur de redirection. On stocke ce status pour `$?`.  
     - Si non (commande externe), on va devoir la lancer via `fork` et `execve`.  
       - On fork un processus enfant. Dans lâ€™enfant, on applique les redirections (comme dans setup_redirections, y compris here-doc via dup du pipe) puis on appelle `execve()`.  
       - La grande question est : **comment trouver le bon exÃ©cutable ?** En effet, si lâ€™utilisateur tape `ls`, il faut chercher dans les dossiers listÃ©s par la variable dâ€™environnement PATH (par ex "/bin", "/usr/bin", etc.). Si lâ€™utilisateur tape un chemin avec `/` (ex `./a.out` ou `/usr/local/bin/python`), alors on essaye directement ce chemin.  
       - Donc, pour une commande externe :  
         - RÃ©cupÃ©rer la liste des chemins dans `PATH` (split par `:`).  
         - Si le nom de commande contient un `/` -> on tente `execve(nom, args, envp)`.  
         - Sinon, pour chaque dossier dans PATH, construire un chemin complet `chemin_dossier/commande` et appeler `execve` avec.  
         - Si `execve` rÃ©ussit, le processus enfant ne revient pas. Sâ€™il Ã©choue, on rÃ©cupÃ¨re `errno`. On essaie le suivant si câ€™Ã©tait ENOENT (fichier non trouvÃ©). Si aucun chemin ne fonctionne, alors la commande nâ€™existe pas : on affiche `minishell: commande: command not found` et on exit(127) dans le child.  
         - Si `execve` Ã©choue pour une raison autre (par ex le fichier existe mais nâ€™est pas exÃ©cutable, ou câ€™est un rÃ©pertoire), on arrÃªte tout de suite et on affiche lâ€™erreur correspondante. Exemples :  
           - Tentative dâ€™exÃ©cuter un fichier sans permission dâ€™exec -> `Permission denied` (code dâ€™erreur 126 typiquement).  
           - Le fichier est un rÃ©pertoire -> Bash dit `bash: ./dir: Is a directory` (Ã©galement code 126).  
           - Pas trouvÃ© -> message `command not found` (code 127). Bash affiche *â€œcommand not foundâ€* pour les commandes sans slash, mais si on met un chemin inexistant, il affiche *â€œNo such file or directoryâ€*. Pour reproduire Ã§a :  
             - Si le command name contient un `/` (chemin explicite) et execve renvoie ENOENT, on affiche *â€œminishell: chemin: No such file or directoryâ€*.  
             - Si pas de slash (recherche PATH) et rien trouvÃ©, *â€œminishell: commande: command not foundâ€*.  
         - Ne pas oublier de free la liste des PATH, etc., dans le parent.  
       - Le parent attend le child (`waitpid`) et rÃ©cupÃ¨re son code.  
   - Si la ligne comporte une **succession de commandes sÃ©parÃ©es par `;`** (pas demandÃ© dans ce projet normalement), on les exÃ©cuterait lâ€™une aprÃ¨s lâ€™autre. (Minishell 42 nâ€™exige pas `;` gÃ©nÃ©ralement.)  
   - Si la ligne comporte des **opÃ©rateurs logiques** `&&` ou `||` (pas demandÃ©s non plus dans Minishell), il faudrait faire en fonction du code de retour prÃ©cÃ©dent.  

Dans le projet courant, on sâ€™arrÃªte aux pipelines et redirections, sans `;` ni `&&`.  

**execve et envp** : Lâ€™appel `execve(path, argv, envp)` nÃ©cessite un tableau `envp` Ã  fournir. On doit construire ce tableau Ã  partir de notre liste chaÃ®nÃ©e dâ€™env (export). On ne met que les variables qui ont un `env->value` non NULL (car un envp ne peut pas contenir de variable sans valeur ? en fait si, VAR= existe possible, mais bon). On peut allouer un tableau de char* de la taille de la liste, et remplir avec `name=value` chaÃ®nes. Câ€™est ce `envp` quâ€™on passe Ã  `execve`.  

**Gestion du `errno` et messages** : Une fois `execve` appelÃ© dans lâ€™enfant, deux cas :  
- SuccÃ¨s : le code du child ne revient jamais dans notre programme (le binaire externe prend le relais).  
- Ã‰chec : on doit imprimer lâ€™erreur. *Attention*, on est dans le processus enfant quand on dÃ©tecte lâ€™Ã©chec de `execve` (car on lâ€™a appelÃ©). Il faut donc afficher le message dâ€™erreur **dans lâ€™enfant**, puis faire `exit(code)` dans lâ€™enfant, sinon lâ€™enfant continuera dâ€™exÃ©cuter du code du shell (ce quâ€™on ne veut pas). Par exemple :  

```c
execve(path, argv, envp);
fprintf(stderr, "minishell: %s: %s\n", argv[0], strerror(errno));
if (errno == ENOENT)
    exit(127);
else 
    exit(126);
```  

On utilise les conventions de codes mentionnÃ©es (127 not found, 126 permission ou autre erreur dâ€™exec).  

Le processus parent, lui, se contentera de constater via `waitpid` que le code de sortie de lâ€™enfant est 126/127 en cas dâ€™erreur, ou autre. Il nâ€™affiche rien de plus (dÃ©jÃ  fait dans lâ€™enfant).  

**Cas particulier** : si la commande est vide (ligne vide ou juste espaces), on ne fait rien (juste rÃ©afficher prompt). Si la commande est uniquement composÃ©e de redirections sans commande derriÃ¨re (ex: `> file` tout seul), Bash considÃ¨re cela comme une erreur de syntaxe (â€œsyntax error near unexpected tokenâ€). Il faut idÃ©alement dÃ©tecter ces erreurs de syntaxe lors du parsing et afficher un message du style `minishell: syntax error near unexpected token '>'` et retourner un code dâ€™erreur 2 (comme Bash). La question ne portait pas sur le parsing syntaxique en dÃ©tail, mais câ€™est un aspect Ã  ne pas oublier dans un minishell complet.  

### 5.1 Boucle principale et ensemble  
Enfin, le shell aura une boucle principale du type :  

```c
while (1) {
    char *input = readline("minishell$ ");
    if (!input) {
        // Ctrl+D (EOF) 
        break;
    }
    if (*input == '\0') {
        free(input);
        continue;
    }
    add_history(input);
    // Parser la ligne en structure de commandes (pipeline)
    t_pipeline *pipeline = parse_input(input);
    free(input);
    if (!pipeline) {
        // erreur de parsing (ex: quotes non fermÃ©es), on peut afficher une erreur et continue
        g_exit_status = 2;
        continue;
    }
    // ExÃ©cuter le pipeline
    int exit_code = execute_pipeline_structure(pipeline, &env);
    g_exit_status = exit_code;
    free_pipeline(pipeline);
}
```

Ici `g_exit_status` est une variable globale qui suit `$?`. On utilise `readline` pour obtenir lâ€™input (librairie GNU Readline permise dans le projet), ce qui gÃ¨re aussi lâ€™historique etc. 

La fonction `execute_pipeline_structure` orchestrerait selon les cas : pipeline multiple ou commande simple, en appelant les fonctions quâ€™on a construites. 

**ConformitÃ© POSIX & 42** :  
- Utiliser uniquement les appels systÃ¨mes autorisÃ©s (pas de `system()` Ã©videmment, ni de execvp â€“ on a `execve`).  
- GÃ©rer correctement les signaux (SIGINT, SIGQUIT) pour quâ€™ils se comportent comme dans Bash (ex: Ctrl+C affiche un prompt nouveau sur ligne suivante sans quitter le shell, Ctrl+\ ne fait rien visible, etc., tandis que dans un child process il faut rÃ©tablir le comportement par dÃ©faut ou ignorer selon consignes). Cela implique Ã©ventuellement de jouer avec `signal()` ou `sigaction()` avant de fork/exec.  
- Pas de fuite de mÃ©moire : chaque allocation (ex: args via parsing, structure pipeline) doit Ãªtre libÃ©rÃ©e une fois plus utilisÃ©e. Pareil pour les descripteurs de fichier : assurez-vous quâ€™ils sont fermÃ©s (sauf 0,1,2 bien sÃ»r) une fois inutiles, pour ne pas perdre des FD Ã  chaque exÃ©cution.  
- Norme de codage 42 : fonctions de moins de 25 lignes, etc. On doit donc dÃ©couper en plusieurs fonctions utilitaires. Par exemple, la gestion dâ€™un pipeline peut Ãªtre rÃ©partie entre une fonction qui crÃ©e les pipes, une fonction qui fork chaque commande, etc.  

**Conseils dâ€™optimisation** :  
- Ã‰vitez les duplications de code : par exemple, utilisez une fonction commune pour appliquer les redirections (input, output, heredoc) aussi bien pour une simple commande que pour chaque segment dâ€™un pipeline.  
- Minimalisme : nâ€™allouez pas inutilement. Par exemple, pour parcourir PATH, on peut `strdup` chaque chemin, ajouter `"/cmd"` et tester, puis free immÃ©diatement. Pas besoin de stocker tous les chemins dans un tableau si on peut les tester un par un.  
- **PrÃ©venir les leaks** : chaque `malloc` doit avoir un `free` correspondant, mÃªme en cas dâ€™erreur (un bon moyen est dâ€™avoir des fonctions de nettoyage du contexte qui sont appelÃ©es avant de retourner en cas dâ€™erreur). Utilisez valgrind pour traquer les leaks une fois votre shell en Ã©tat de marche.  
- **Erreurs fatales** : en cas dâ€™erreur critique (ex: `pipe()` ou `fork()` qui Ã©choue, par manque de ressources), il est acceptable de afficher un message et Ã©ventuellement quitter le shell. Ces cas sont rares, mais ne pas ignorer la valeur de retour de ces appels.  
- **Structures de donnÃ©es** : optez pour des structures simples. Par exemple, une liste chaÃ®nÃ©e de commandes pour un pipeline, oÃ¹ chaque nÅ“ud contient ses args (tableau de char*), les infos de redir (infile, outfile, delimiter heredoc, etc.), et pointeur vers suivant. Câ€™est suffisant. Un arbre nâ€™est pas forcÃ©ment nÃ©cessaire dans un minishell sans `&&` ni `;`.  

En suivant ce guide, vous devriez obtenir un minishell fonctionnel qui gÃ¨re correctement les pipes en sÃ©rie, les redirections (y compris multiples), les here-documents avec expansions appropriÃ©es, les commandes built-in et lâ€™exÃ©cution de programmes externes via `execve`. Ã€ chaque Ã©tape, comparez le comportement avec Bash pour vous assurer de la conformitÃ© (messages dâ€™erreur, retours, etc.), car le diable est dans les dÃ©tails en programmation de shell. Bon codage !

